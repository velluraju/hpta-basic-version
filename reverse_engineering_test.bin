#!/usr/bin/env python3
"""
HPTA Reverse Engineering Test Binary
Complex binary sample for testing reverse engineering capabilities
"""

import struct
import hashlib
import base64
from datetime import datetime

class ReverseEngineeringTestBinary:
    def __init__(self):
        """Initialize complex binary with reverse engineering challenges"""
        # Simulated PE header structure
        self.pe_header = {
            'signature': b'PE\x00\x00',
            'machine': 0x014c,  # IMAGE_FILE_MACHINE_I386
            'number_of_sections': 5,
            'time_date_stamp': int(datetime.now().timestamp()),
            'characteristics': 0x0102,  # IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_32BIT_MACHINE
            'optional_header_size': 224,
            'entry_point': 0x00401000,
            'image_base': 0x00400000,
            'section_alignment': 0x1000,
            'file_alignment': 0x200
        }
        
        # Obfuscated function table
        self.function_table = [
            ('sub_401000', 0x401000, 'main_entry_point'),
            ('sub_401050', 0x401050, 'string_decrypt'),
            ('sub_4010A0', 0x4010A0, 'network_communicate'),
            ('sub_401100', 0x401100, 'file_operations'),
            ('sub_401150', 0x401150, 'registry_modify'),
            ('sub_4011A0', 0x4011A0, 'process_inject'),
            ('sub_401200', 0x401200, 'anti_debug'),
            ('sub_401250', 0x401250, 'vm_detect'),
            ('sub_4012A0', 0x4012A0, 'payload_decode'),
            ('sub_401300', 0x401300, 'persistence_install')
        ]
        
        # Encrypted strings (XOR with key 0x42)
        self.encrypted_strings = [
            self.xor_encrypt("CreateRemoteThread", 0x42),
            self.xor_encrypt("VirtualAllocEx", 0x42),
            self.xor_encrypt("WriteProcessMemory", 0x42),
            self.xor_encrypt("malware-c2.test.local", 0x42),
            self.xor_encrypt("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0x42),
            self.xor_encrypt("C:\\Windows\\System32\\kernel32.dll", 0x42),
            self.xor_encrypt("GET /command HTTP/1.1", 0x42),
            self.xor_encrypt("User-Agent: Mozilla/5.0", 0x42)
        ]
        
        # Fake assembly instructions (x86)
        self.assembly_code = [
            b'\x55',                    # push ebp
            b'\x8B\xEC',                # mov ebp, esp
            b'\x83\xEC\x10',            # sub esp, 10h
            b'\x68\x00\x30\x40\x00',    # push offset string
            b'\xFF\x15\x00\x20\x40\x00', # call CreateRemoteThread
            b'\x85\xC0',                # test eax, eax
            b'\x74\x05',                # jz short error_handler
            b'\xB8\x01\x00\x00\x00',    # mov eax, 1
            b'\xEB\x03',                # jmp short exit
            b'\x33\xC0',                # xor eax, eax
            b'\x8B\xE5',                # mov esp, ebp
            b'\x5D',                    # pop ebp
            b'\xC3'                     # ret
        ]

    def xor_encrypt(self, data, key):
        """Simple XOR encryption for string obfuscation"""
        if isinstance(data, str):
            data = data.encode('utf-8')
        return bytes([b ^ key for b in data])

    def generate_import_table(self):
        """Generate suspicious import table"""
        imports = {
            'KERNEL32.DLL': [
                'CreateRemoteThread',
                'VirtualAllocEx', 
                'WriteProcessMemory',
                'CreateToolhelp32Snapshot',
                'Process32First',
                'Process32Next',
                'OpenProcess',
                'GetProcAddress',
                'LoadLibraryA',
                'CreateMutexA',
                'CreateFileA',
                'GetModuleHandleA'
            ],
            'NTDLL.DLL': [
                'NtCreateThreadEx',
                'NtWriteVirtualMemory',
                'NtQuerySystemInformation',
                'NtSetInformationProcess',
                'RtlCreateUserThread'
            ],
            'ADVAPI32.DLL': [
                'RegCreateKeyExA',
                'RegSetValueExA',
                'OpenProcessToken',
                'LookupPrivilegeValueA',
                'AdjustTokenPrivileges'
            ],
            'WININET.DLL': [
                'InternetOpenA',
                'InternetConnectA', 
                'HttpOpenRequestA',
                'HttpSendRequestA',
                'InternetReadFile'
            ],
            'USER32.DLL': [
                'FindWindowA',
                'SetWindowsHookExA',
                'GetAsyncKeyState',
                'RegisterHotKeyA'
            ]
        }
        return imports

    def generate_export_table(self):
        """Generate export table for DLL analysis"""
        exports = [
            ('DllMain', 0x10001000),
            ('ServiceMain', 0x10001050),
            ('InstallHook', 0x100010A0),
            ('RemoveHook', 0x100010F0),
            ('StartMonitoring', 0x10001140),
            ('StopMonitoring', 0x10001190),
            ('SendData', 0x100011E0),
            ('ReceiveCommands', 0x10001230)
        ]
        return exports

    def calculate_entropy(self, data):
        """Calculate entropy to detect packing/encryption"""
        if len(data) == 0:
            return 0
        
        # Count byte frequencies
        frequencies = [0] * 256
        for byte in data:
            frequencies[byte] += 1
        
        # Calculate entropy
        entropy = 0
        for freq in frequencies:
            if freq > 0:
                p = freq / len(data)
                entropy -= p * (p.bit_length() - 1)
        
        return entropy

    def generate_code_cave(self):
        """Generate code cave for injection analysis"""
        cave_code = b'\x90' * 100  # NOP sled
        cave_code += b'\x60'       # pushad
        cave_code += b'\x61'       # popad
        cave_code += b'\xC3'       # ret
        return cave_code

    def create_packed_section(self):
        """Create high-entropy section simulating packing"""
        # Generate pseudo-random data to simulate packed/encrypted section
        packed_data = b''
        for i in range(1024):
            packed_data += struct.pack('B', (i * 137 + 42) % 256)
        return packed_data

    def generate_relocation_table(self):
        """Generate relocation table for address analysis"""
        relocations = []
        base_addr = 0x00401000
        
        for i in range(50):
            rva = base_addr + (i * 4)
            relocations.append(('IMAGE_REL_BASED_HIGHLOW', rva))
        
        return relocations

    def create_resource_section(self):
        """Create resource section with embedded data"""
        resources = {
            'ICON': b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR',
            'VERSION': b'FileVersion\x001.0.0.0\x00',
            'STRING': b'Internal Name\x00SystemUpdate.exe\x00',
            'MANIFEST': b'<?xml version="1.0" encoding="UTF-8"?>'
        }
        return resources

    def analyze_control_flow(self):
        """Simulate control flow analysis challenges"""
        control_flow = {
            'entry_points': [0x401000, 0x401500, 0x402000],
            'jump_tables': [0x403000, 0x403100],
            'indirect_calls': [0x404000, 0x404050, 0x404100],
            'anti_disassembly': [0x405000, 0x405020],
            'obfuscated_jumps': [0x406000, 0x406010, 0x406020]
        }
        return control_flow

    def generate_binary_analysis_report(self):
        """Generate comprehensive binary analysis report"""
        print("="*80)
        print("HPTA REVERSE ENGINEERING TEST BINARY ANALYSIS")
        print("="*80)
        
        # PE Header Analysis
        print("\n[PE HEADER ANALYSIS]")
        print(f"Machine Type: 0x{self.pe_header['machine']:04X} (i386)")
        print(f"Number of Sections: {self.pe_header['number_of_sections']}")
        print(f"Entry Point: 0x{self.pe_header['entry_point']:08X}")
        print(f"Image Base: 0x{self.pe_header['image_base']:08X}")
        
        # Import Analysis
        print("\n[IMPORT ANALYSIS]")
        imports = self.generate_import_table()
        for dll, functions in imports.items():
            print(f"{dll}:")
            for func in functions[:3]:  # Show first 3 functions
                print(f"  - {func}")
            if len(functions) > 3:
                print(f"  ... and {len(functions)-3} more")
        
        # Export Analysis
        print("\n[EXPORT ANALYSIS]")
        exports = self.generate_export_table()
        for name, rva in exports[:5]:
            print(f"  {name} @ 0x{rva:08X}")
        
        # Entropy Analysis
        packed_section = self.create_packed_section()
        entropy = self.calculate_entropy(packed_section)
        print(f"\n[ENTROPY ANALYSIS]")
        print(f"Section Entropy: {entropy:.2f}")
        if entropy > 7.0:
            print("  WARNING: High entropy detected - possible packing/encryption")
        
        # String Analysis
        print("\n[STRING ANALYSIS]")
        print("Encrypted strings found:")
        for i, enc_str in enumerate(self.encrypted_strings[:3]):
            decrypted = self.xor_encrypt(enc_str, 0x42).decode('utf-8', errors='ignore')
            print(f"  String {i+1}: {decrypted}")
        
        # Control Flow Analysis
        print("\n[CONTROL FLOW ANALYSIS]")
        cf = self.analyze_control_flow()
        print(f"Entry Points: {len(cf['entry_points'])}")
        print(f"Jump Tables: {len(cf['jump_tables'])}")
        print(f"Indirect Calls: {len(cf['indirect_calls'])}")
        print(f"Anti-Disassembly Techniques: {len(cf['anti_disassembly'])}")
        
        # Code Cave Analysis
        print("\n[CODE CAVE ANALYSIS]")
        cave = self.generate_code_cave()
        print(f"Code cave size: {len(cave)} bytes")
        print("Potential injection point detected")
        
        # Resource Analysis
        print("\n[RESOURCE ANALYSIS]")
        resources = self.create_resource_section()
        for res_type in resources.keys():
            print(f"  {res_type} resource found")
        
        print("\n[SECURITY ASSESSMENT]")
        print("Suspicious characteristics detected:")
        print("  ✓ Process injection APIs")
        print("  ✓ Registry modification capabilities")
        print("  ✓ Network communication functions")
        print("  ✓ Anti-analysis techniques")
        print("  ✓ High entropy sections")
        print("  ✓ Obfuscated strings")
        print("  ✓ Complex control flow")
        
        print("\n[REVERSE ENGINEERING CHALLENGES]")
        print("This binary presents the following analysis challenges:")
        print("  - String obfuscation with XOR encryption")
        print("  - Packed/encrypted sections")
        print("  - Anti-disassembly techniques")
        print("  - Indirect function calls")
        print("  - Complex control flow patterns")
        print("  - Multiple entry points")
        print("  - Resource section analysis")
        
        print("\n" + "="*80)
        print("Binary ready for reverse engineering analysis!")
        print("This is a HARMLESS test file for HPTA Security Suite")
        print("="*80)

if __name__ == "__main__":
    # Create and analyze the test binary
    test_binary = ReverseEngineeringTestBinary()
    test_binary.generate_binary_analysis_report()
    
    # Generate binary fingerprint
    binary_data = str(test_binary.pe_header).encode() + b''.join(test_binary.encrypted_strings)
    fingerprint = hashlib.sha256(binary_data).hexdigest()
    print(f"\nBinary Fingerprint: {fingerprint}")
    print(f"File Location: {__file__}")
